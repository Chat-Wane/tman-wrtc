<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">lib/tman.js | tman-wrtc API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/ran3d/tman-wrtc.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/cache.js~Cache.html">Cache</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/partialview.js~PartialView.html">PartialView</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/tman.js~TMan.html">TMan</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-N2N">N2N</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">entries</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/entries/epv.js~EPV.html">EPV</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">exceptions</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/exceptions/exjoin.js~ExJoin.html">ExJoin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/exceptions/exmessage.js~ExMessage.html">ExMessage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/exceptions/expeernotfound.js~ExPeerNotFound.html">ExPeerNotFound</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">messages</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/messages/mgivedescriptor.js~MGiveDescriptor.html">MGiveDescriptor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/messages/mjoin.js~MJoin.html">MJoin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/messages/mrequestdescriptor.js~MRequestDescriptor.html">MRequestDescriptor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/messages/mrequire.js~MRequire.html">MRequire</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/messages/msuggest.js~MSuggest.html">MSuggest</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/messages/msuggestback.js~MSuggestBack.html">MSuggestBack</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/tman.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;;

const debug = require(&apos;debug&apos;)(&apos;tman-wrtc&apos;);
const N2N = require(&apos;n2n-overlay-wrtc&apos;);
const U = require(&apos;unicast-definition&apos;);
const _ = require(&apos;lodash&apos;);

const PartialView = require(&apos;./partialview.js&apos;);
const Cache = require(&apos;./cache.js&apos;);

const MJoin = require(&apos;./messages/mjoin.js&apos;);
const MSuggest = require(&apos;./messages/msuggest.js&apos;);
const MSuggestBack = require(&apos;./messages/msuggestback.js&apos;);
const MRequire = require(&apos;./messages/mrequire.js&apos;);
const MGiveDescriptor = require(&apos;./messages/mgivedescriptor.js&apos;);
const MRequestDescriptor = require(&apos;./messages/mrequestdescriptor.js&apos;);

const ExMessage = require(&apos;./exceptions/exmessage.js&apos;);
const ExJoin = require(&apos;./exceptions/exjoin.js&apos;);

/**
 * Peer-sampling protocol running on top of WebRTC that builds network
 * topologies using ranking functions.
 */
class TMan extends N2N {
    /**
     * @param {object} [options] Options given to TMan to build the desired
     * topology.
     * @param {string} [options.pid = &apos;tman-wrtc&apos;] The identifier of this
     * protocol.
     * @param {number} [options.delta = 60000] Every delta millisecond, exchange
     * neighbors of the partial view.
     * @param {number} [options.timeout = 120000] WebRTC connections are
     * expensive to establish, may fail, etc. Instead of immediately removing
     * them, the protocol keep them warm during options.timeout
     * milliseconds. Consequently, messages transiting through them can still be
     * transmitted, and if the protocol requires such an arc, it can be
     * reestablished at no cost.
     * @param {number} [options.descriptorTimeout = 10000] Peers regularly ask
     * for descriptor and await an answer. If this answer does not come up in
     * time, it throws an exception.
     * @param {IPSP} [parent] This module can depend of another peer-sampling
     * protocol. If set, it will share the neighbors populating its inview and
     * outview. Thus, the above options will be of no use. See neigbhorhood-wrtc
     * module for more informations on the sharing process.
     */
    constructor (options = {}, parent) {
        // #0 initialize our N2N-parent
        super( _.merge({ pid: &apos;tman-wrtc&apos;,
                         delta: 1 * 60 * 1000,
                         timeout: 2 * 60 * 1000,
                         descriptorTimeout: 10* 1000,
                         retry: 5,
                         inview: parent &amp;&amp; parent.NI,
                         outview: parent &amp;&amp; parent.NO,
                         descriptor: {x: Math.random()},
                         ranking: (neighbor) =&gt; (a, b) =&gt; {
                             const db = b.descriptor.x - neighbor.descriptor.x;
                             const da = a.descriptor.x - neighbor.descriptor.x;
                             return Math.abs(da) - Math.abs(db);
                         }}, options) );
        // #1 constants (from N2N): this.PID, this.PEER
        debug(&apos;[%s] Initalized with ==&gt; %s ==&gt;&apos;, this.PID, this.PEER);
        // #2 initialize the partial view
        this.partialView = new PartialView();
        this.cache = new Cache(this.options.timeout);
        // #3 connectedness state of this protocol
        this.state = &apos;disconnected&apos;;
        // #4 periodic shuffling
        this.periodic = null;
        // #5 events
        this.on(&apos;receive&apos;, (peerId, message) =&gt; this._receive(peerId, message));
        // this.on(&apos;stream&apos;, (peerId, message) =&gt;  ); // (TODO) ?;
        this.on(&apos;open&apos;, (peerId) =&gt; {
            this._open(peerId);
            this._updateState();
        });
        this.on(&apos;close&apos;, (peerId) =&gt; {
            this._close(peerId);
            this._updateState();
        });
        this.on(&apos;fail&apos;, (peerId) =&gt; {
            this._onArcDown(peerId);
            this._updateState();
        });
        // #6 if has parent, register events to get descriptors
        this.parent = parent || null;
        if (this.parent) {
            this.unicast = new U(this.parent,
                                 {pid: &apos;tman-wrtc-unicast&apos;,
                                  retry: this.options.retry} );
            
            this.parent.on(&apos;open&apos;, (peerId) =&gt;
                           !this.cache.has(peerId) &amp;&amp;
                           this.unicast.emit(&apos;requestDescriptor&apos;,
                                             peerId, this.getOutviewId())
                           .catch( (e) =&gt; { } ));
            
            this.unicast.on(&apos;requestDescriptor&apos;, (requester) =&gt;
                            this.unicast.emit(&apos;giveDescriptor&apos;, requester,
                                              this.getInviewId(),
                                              this.options.descriptor)
                            .catch( (e) =&gt; { } ));
            this.unicast.on(&apos;giveDescriptor&apos;, (peerId, descriptor) =&gt; {
                if (!this.cache.has(peerId)) {
                    debug(&apos;[%s] get %s\&apos;s descriptor from %s.&apos;,
                          this.PID, peerId, this.parent.PID);
                    this.cache.add(peerId, descriptor);
                };
            });
        };
    };

    /**
     * Joining a network.
     * @param {callback} sender Function that will be called each time an offer
     * arrives to this peer. It is the responsability of the caller to send 
     * these offer (using sender) to the contact inside the network.
     * @returns {Promise} A promise that is resolved when the peer joins the 
     * network; rejected after a timeout, or already connected state.
     */
    join (sender) {
        this.parent &amp;&amp; this.parent.join(sender);
        let result = new Promise( (resolve, reject) =&gt; {
            // #0 connectedness state check
            (this.state !== &apos;disconnected&apos;) &amp;&amp;
                reject(new ExJoin(&apos;join&apos;, &apos;Already connected.&apos;));
            // #1 set timeout before reject
            let to = setTimeout( () =&gt; {
                reject(new ExJoin(&apos;join&apos;, &apos;Timeout exceeded.&apos;));
            }, this.options.timeout);
            // #2 very first call, only done once
            this.once(&apos;open&apos;, (peerId) =&gt; {
                this.send(peerId,
                          new MJoin(this.getInviewId(),this.options.descriptor),
                          this.options.retry).then( () =&gt; {
                              clearTimeout(to);
                              this._start(); 
                              resolve(peerId);
                          }).catch( () =&gt; {
                              reject( new ExJoin(&apos;join&apos;,
                                                 &apos;Could not notify contact.&apos;));
                          });
            });
        });
        // #3 start the very first connection of this peer
        this.connect(sender);
        return result;
    };
    
    /**
     * @private Behavior when a peer just joined the network through this peer.
     * @param {string} peerId The identifier of the newcomer.
     * @param {MJoin} message The message sent by the newcomer.
     */
    _onJoin (peerId, message) {
        if (this.partialView.size &gt; 0){
            // #1 all neigbors -&gt; peerId
            debug(&apos;[%s] %s ===&gt; join %s; %s neigbhors ===&gt; %s&apos;,
                  this.PID, peerId, this.PEER, this.partialView.size, peerId);
            let neighbors = [];
            this.partialView.forEach( (epv, neighbor) =&gt; {
                neighbors.push({peer: epv.peer, descriptor: epv.descriptor});
            });
            neighbors.push({peer:this.getInviewId(),
                            descriptor: this.options.descriptor});
            this.send(peerId,
                      new MSuggestBack(neighbors),
                      this.options.retry).catch( (e) =&gt; { } );
        } else {
            // #2 this -&gt; peerId
            debug(&apos;[%s] %s ===&gt; join %s ===&gt; %s&apos;,
                  this.PID, peerId, this.PEER, peerId);
            this.cache.add(message.peer, message.descriptor);
            this.connect(null, peerId);
            this.send(peerId,
                      new MSuggestBack([{peer:this.getInviewId(),
                                         descriptor: this.options.descriptor}]),
                      this.options.retry).catch( (e) =&gt; { } );
            this._start();
        };
    };

    /**
     * @private Behavior when a WebRTC connection failed to establish properly
     * @param {string|null} peerId The identifier of the peer with which we
     * failed to create a connection. Null if it was yet to be known.
     */
    _onArcDown (peerId) {
        // Do nothing.
    };

    /**
     * @private Behavior when a peer seems down. This is called when, during an
     * exchange, this protocol chooses a down peer to exchange with.
     * @param {string} peerId The identifier of the peer that seems
     * left/crashed.
     */
    _onPeerDown (peerId) {
        this.partialView.removeAllNeighbor(peerId);
    };

    /**
     * @private Getter for the size of the sample to send to the remote chosen
     * peer.
     * @param {string[]} flatten Array of identifiers.
     * @return {number} The size of the sample to create.
     */
    _sampleSize (flatten) {
        return Math.min(flatten.length, 2);
    };

    /**
     * @private Getter for the maximum partial view size.
     */
    _partialViewSize () {
        return 4;
    };
    
    /**
     * @private Get a sample of the partial view.
     * @param {object} neighbor Object containing .peer for identifier of the
     * peer to exchange with and .descriptor for the peer&apos;s descriptor.
     * @returns {object[]} Array of object containing .peer and .descriptor.
     */
    _getSample (neighbor) {
        // #1 create a flatten version of the partial view
        let flatten = [];
        // #A extract the partial view of tman
        this.partialView.forEach( (epv, peerId) =&gt; {
            epv.ages.forEach( (age) =&gt; {
                !_.isEmpty(epv.descriptor) &amp;&amp; flatten.push(peerId);
            });
        });
        // #B add random peers from parent
        this.parent &amp;&amp; this.parent.partialView.forEach( (ages, peerId) =&gt; {
            if (this.cache.has(peerId) &amp;&amp; flatten.indexOf(peerId) &lt; 0) {
                flatten.push(peerId);
            };
        });
        // #2 replace all peerId occurrences by ours
        flatten = flatten.map( (peerId) =&gt; {
            let d = {descriptor: this.options.descriptor};
            if (peerId === neighbor.peer){
                d.peer = this.getInviewId();
            } else {
                d.descriptor = (this.cache.has(peerId)&amp;&amp;this.cache.get(peerId))
                    || this.partialView.getDescriptor(peerId);
                d.peer = peerId;
            };
            return d;
        });
        // #3 process the size of the sample
        const sampleSize = this._sampleSize(flatten);
        // #4 rank according to PeerId
        flatten.sort( this.options.ranking(neighbor) );
        return flatten.slice(0, sampleSize);  
    };

    /**
     * @private Periodically called function that aims to distribute links among
     * peers according to the desired property.
     */
    _exchange () {
        // #0 if the partial view is empty --- could be due to disconnections,
        // failure, or _onExchange started with other peers --- skip this round.
        if (this.partialView.size &lt;= 0 &amp;&amp;
            this.parent &amp;&amp; this.parent.partialView.size &lt;= 0) {
            return;
        }
        this.partialView.increment();
        // #1 get the oldest peer in our partial view. If the partial view is
        // empty, fall back to parent&apos;s partial view.
        let chosen;
        let sample;
        let fromOurOwn = true;
        if (this.partialView.size &gt; 0) {
            // #A use our own partial view
            chosen = this.partialView.oldest;
            sample = this._getSample(this.partialView.get(chosen));
        } else if (this.parent &amp;&amp; this.parent.partialView.size &gt; 0) {
            // #B use the partial view of our parent
            let rnNeighbors = this.parent.getPeers();
            let found = false;
            fromOurOwn = false;
            while (!found &amp;&amp; rnNeighbors.length &gt; 0){
                const rn = Math.floor(Math.random() * rnNeighbors.length);
                if (this.cache.has(rnNeighbors[rn])){
                    found = true;
                    chosen = rnNeighbors[rn];
                    sample = this._getSample({peer: chosen,
                                              descriptor: this.cache.get(chosen)
                                             });
                } else {
                    rnNeighbors.splice(rn, 1);
                };
            };          
        };
        // #2 propose the sample to the chosen one
        chosen &amp;&amp; this.send(chosen, new MSuggest(this.getInviewId(),
                                                 this.options.descriptor,
                                                 sample))
            .then( () =&gt; {
                // #A it seems the message has been sent correctly
                debug(&apos;[%s] %s ==&gt; suggest %s ==&gt; %s&apos;,
                      this.PID, this.PEER, sample.length, chosen); })
            .catch( (e) =&gt; {
                // #B the peer cannot be reached, he is supposedly dead
                debug(&apos;[%s] %s =X&gt; suggest =X&gt; %s&apos;,
                      this.PID, this.PEER, chosen);
                fromOurOwn &amp;&amp; this._onPeerDown(chosen); });
    };
    
    /**
     * @private Behavior when this peer receives suggestions from another peer
     * running its periodic protocol.
     * @param {string} peerId The identifier of the initiating peer.
     * @param {ISuggest} message The message containing the suggestions.
     */
    _onExchange (peerId, message) {
        // #1 prepare the sample to send back
        const sample = this._getSample(message);
        this.send(peerId, new MSuggestBack(sample), this.options.retry)
            .then( () =&gt; {
                debug(&apos;[%s] %s ==&gt; suggest back %s ==&gt; %s&apos;,
                      this.PID, this.PEER, sample.length, peerId);
            })
            .catch ( (e) =&gt; { } );
        // #2 analyze the received sample and keep the elements if they are
        // better than the current ones
        this._onExchangeBack(peerId, message);
    };

    /**
     * @private Determines which peers are tokeep and which are toreject.
     * @param {string} peerId The identifier of the peer that sent the message.
     * @param {MSuggest|MSuggestBack} message The message received.
     */
    _onExchangeBack (peerId, message) {
        // #1 keep the best elements from the received sample
        let ranked = [];
        this.partialView.forEach( (epv, neighbor) =&gt; ranked.push(epv));
        message.sample.forEach( (e) =&gt; ranked.indexOf(e) &lt; 0 &amp;&amp;
                                ranked.push(e) );
        
        ranked.sort( this.options.ranking(this.options) );
        // #2 require the elements
        let sliced = ranked.slice(0, this._partialViewSize());
        let request = [];
        sliced.forEach( (e) =&gt; {
            if (!this.partialView.has(e.peer)) {
                request.push(e.peer);
                this.cache.add(e.peer, e.descriptor);
            };
        });
        if (request.length &gt; 0) {
            debug(&apos;[%s] %s wants to keep %s peers.&apos;,
                  this.PID, this.PEER, request.length);
            this.send(peerId, new MRequire(request), this.options.retry)
                .catch( (e) =&gt; {
                    debug(&apos;[%s] %s =X&gt; request descriptors %s =X&gt; %s&apos;,
                          this.PID, this.PEER, request.length, peerId);
                });
        };
        
        let rest = ranked.slice(this._partialViewSize(), ranked.length);
        if (rest.length &gt; 0 &amp;&amp; this.partialView.size &gt; this._partialViewSize()){
            rest.forEach( (p) =&gt; {
                this.partialView.has(p.peer) &amp;&amp; this.disconnect(p.peer);
            });
        };
    };
    
    /**
     * @private A peer requested to be connected with a set of neighbors.
     * @param {string} peerId The identifier of the peer that requests
     * connections.
     * @param {MRequire} message The request message.
     */
    _onRequire (peerId, message) {
        // #1 bridge the requester and the requested peers
        debug(&apos;[%s] %s requested to be bridged with %s peers&apos;,
              this.PID, peerId, message.peers.length);
        message.peers.forEach( (neighbor) =&gt; {
            this.connect(peerId, neighbor);
        });
    };

    /**
     * @private Called each time this protocol receives a message. It processes
     * its own and the rest is redirected to the appropriate registered
     * protocol.
     * @param {string} peerId The identifier of the peer that sent the message.
     * @param {object|MExchange} message The message received.
     */
    _receive (peerId, message) {
        if (message.type &amp;&amp; message.type === &apos;MSuggest&apos;) {
            this._onExchange(peerId, message);
        } else if (message.type &amp;&amp; message.type === &apos;MSuggestBack&apos;) {
            this._onExchangeBack(peerId, message);
        } else if (message.type &amp;&amp; message.type === &apos;MRequire&apos;) {
            this._onRequire(peerId, message);
        } else if (message.type &amp;&amp; message.type === &apos;MJoin&apos;) {
            this._onJoin(peerId, message);
        } else if (message.type &amp;&amp; message.type === &apos;MGiveDescriptor&apos;) {
            this.emit(this.PID + &apos;-&apos; + peerId, message);
        } else if (message.type &amp;&amp; message.type === &apos;MRequestDescriptor&apos;) {
            this._onRequestDescriptor(peerId, message);
        } else {
            throw new ExMessage(&apos;_receive&apos;, message, &apos;unhandled&apos;);
        };
    };
    
    /**
     * @private Start periodic shuffling.
     */
    _start (delay = this.options.delta) {
        this.periodic = setInterval( () =&gt; this._exchange(), delay);
    };

    /**
     * @private Stop periodic shuffling.
     */
    _stop () {
        this.periodic &amp;&amp; clearInterval(this.periodic);
    };

    /**
     * @private Get the descriptor from a remote Peer
     * @param {string} peerId The identifier of the peer.
     * @returns {Promise} Resolved when the descriptor has been added to our
     * cache; Rejected after a timeout or an error when sending the message.
     */
    _requestDescriptor (peerId) {
        return new Promise( (resolve, reject) =&gt; {
            let to = null;
            this.send(peerId, new MRequestDescriptor(), this.options.retry)
                .then( () =&gt; {
                    to = setTimeout( () =&gt; {
                        this.removeAllListeners(this.PID + &apos;-&apos; + peerId);
                        reject(&apos;timeout&apos;); // (TODO) throw exception
                    }, this.options.descriptorTimeout);
                }).catch( (e) =&gt; {
                    reject(e);
                });
            
            this.once(this.PID + &apos;-&apos; + peerId, (message) =&gt; {
                clearTimeout(to);
                this.cache.add(message.peer, message.descriptor);
                resolve();
            });
        });
    };

    /**
     * @private Behavior when this peer receives a request of descriptor.
     * @param {string} peerId The identifier of the requester.
     * @param {MRequestDescriptor} message The message received.
     */
    _onRequestDescriptor (peerId, message) {
        this.send(peerId, new MGiveDescriptor(this.getInviewId(),
                                              this.options.descriptor),
                  this.options.retry)
            .catch( (e) =&gt; debug(&apos;[%s] %s =X&gt; give descriptor =X&gt; %s&apos;,
                                 this.PID, this.PEER, peerId) );
    };
    
    /**
     * @private Behavior when a connection is ready to be added in the partial
     * view.
     * @param {string} peerId The identifier of the new neighbor.
     */
    _open (peerId) {
        debug(&apos;[%s] %s ===&gt; %s&apos;, this.PID, this.PEER, peerId);
        // #1 Check if it is already in the view. We do not want duplicate. Such
        // cases happen due to concurrency. Check if the descriptor is still in
        // the cache.
        if (this.partialView.has(peerId)) {
            this.disconnect(peerId);
        } else if (!this.cache.has(peerId)) {
            this._requestDescriptor(peerId)
                .then( () =&gt; {
                    // #2 re-check for it may have been added in the meantime
                    if (this.partialView.has(peerId)){
                        this.disconnect(peerId);
                    } else {
                        // #3 rank peers to check which is to throw, if there is
                        this._keep(peerId);
                    }; })
                .catch( (e) =&gt; {
                    this.disconnect(peerId);
                });
        } else {
            // #3 rank peers to check which is to throw, if there is
            this._keep(peerId);
        };
    };

    /**
     * @private Check if the new peer should be added to our partial view or
     * rejected
     * @param {string} peerId The identifier of the peer to check.
     */
    _keep (peerId) {
        let ranked = [];
        this.partialView.forEach( (epv, neighbor) =&gt; ranked.push(epv));
        ranked.push({peer: peerId, descriptor: this.cache.get(peerId) });
        ranked.sort( this.options.ranking(this.options) );
        let sliced = ranked.slice(0, this._partialViewSize());
        ranked.splice(0, this._partialViewSize());
        // ranked becomes the rest: the lowest graded
        if (ranked.length === 0 || ranked.indexOf(peerId) &lt; 0) {
            this.partialView.addNeighbor(peerId, this.cache.get(peerId));
        };
        ranked.forEach( (neighbor) =&gt; this.disconnect(neighbor.peer) );
    };
    
    /**
     * @private Behavior when a connection is closed.
     * @param {string} peerId The identifier of the removed arc.
     */
    _close (peerId) {
        debug(&apos;[%s] %s =&#x2020;=&gt; %s&apos;, this.PID, this.PEER, peerId);
        this.partialView.has(peerId) &amp;&amp; this.partialView.removeOldest(peerId);
    };
    
    /**
     * @private Update the connectedness state of the peer.
     */
    _updateState () {
        const remember = this.state;
        if (this.i.size &gt; 0 &amp;&amp; this.o.size &gt; 0 &amp;&amp; remember !== &apos;connected&apos;){
            this.state = &apos;connected&apos;;
        } else if ((this.i.size &gt; 0 &amp;&amp; this.o.size &lt;= 0 ||
                    this.o.size &gt; 0 &amp;&amp; this.i.size &lt;= 0) &amp;&amp;
                   remember !== &apos;partially connected&apos;){
            this.state = &apos;partially connected&apos;;
        } else if (this.i.size &lt;= 0 &amp;&amp; this.o.size &lt;= 0 &amp;&amp;
                   remember !== &apos;disconnected&apos;) {
            this.state = &apos;disconnected&apos;;
            // this._stop();
        };
        (remember !== this.state) &amp;&amp; this.emit(&apos;statechange&apos;, this.state);
    };

    /**
     * Get k neighbors from the partial view. If k is not reached, it tries to
     * fill the gap with neighbors from the inview.  It is worth noting that
     * each peer controls its outview but not its inview. The more the neigbhors
     * from the outview the better.
     * @param {number} k The number of neighbors requested. If k is not defined,
     * it returns every known identifiers of the partial view.
     * @return {string[]} Array of identifiers.
     */
    getPeers (k) {
        let peers = []; 
        if (typeof k === &apos;undefined&apos;) {
            // #1 get all the partial view
            this.partialView.forEach( (epv, peerId) =&gt; peers.push(peerId) );
        } else {
            // #2 get random identifier from outview
            let out = [];
            this.partialView.forEach( (epv, peerId) =&gt; out.push(peerId) );
            while (peers.length &lt; k &amp;&amp; out.length &gt; 0) {
                let rn = Math.floor( Math.random() * out.length );
                peers.push( out[rn] );
                out.splice( rn, 1 );
            };
            // #3 get random identifier from the inview to fill k-entries
            let inView = [];
            this.i.forEach( (occ, peerId) =&gt; inView.push(peerId) );
            while (peers.length &lt; k &amp;&amp; inView.length &gt; 0){
                let rn = Math.floor( Math.random() * inView.length );
                peers.push( inView[rn] );
                inView.splice( rn, 1 );
            };
        };
        debug(&apos;[%s] %s provides %s peers&apos;, this.PID, this.PEER, peers.length);
        return peers;
    };
};

module.exports = TMan;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
